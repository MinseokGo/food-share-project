# 배달음식 공유 플랫폼 : (서비스 이름)

### 시나리오

1. 배달 음식 공유 기능

1인가구 석민씨와 2명의 아들을 둔 민소씨가 있습니다. 석민씨는 탕수육이 먹고싶지만 혼자 큰 탕수육을 배달받기는 부담스럽기만 합니다. 민소씨의 큰 아들은 탕수육이 먹고싶다고 하며, 작은 아들은 치킨을 먹고싶다고 합니다. 두 아들은 각 음식을 절반 정도 먹을 수 있다고 합니다. 

두 가구는 최근에 출시된 해당 시스템에 접속하게 됩니다. 민소씨가 ‘공유’라는 페이지로 이동합니다. “ ‘연산루’에서 탕수육, ‘김해통닭’에서 치킨 한 마리를 같이 공유할 분~! ”이라며 글을 게시합니다. 마침 이 게시글을 본 석민씨는 게시물을 확인하여 ‘공유 참여’를 하게 됩니다. 이때 또 치킨이 먹고싶었던 1인가구 안씨도 치킨공유에 동참합니다. 이후 모든 참여자가 동의하게 되었고, 석민씨, 민소씨, 안씨 각자 결제하게 됩니다. 채팅을 통해 ‘연산동 탑골공원’에서 만나기로 합니다. 각 가게에서 주문한 음식 배달은 탑골공원으로 도착하였고 만나기로 한 시간에 만나 모두 자기가 원하는 양을 가져갑니다.

이렇게 석민씨, 민소씨, 안씨는 배달비를 절반만 내게 되었고 원하는 양의 원하는 음식을 얻게 되었습니다. 또한 음식물 쓰레기가 적게 생겨날 것입니다. 하지만 절반 단위의 용기가 미리 준비되어야 합니다.

2. 가게의 남은 음식 공유

밀양에서 작은 분식집을 운영하는 진은씨가 있습니다. 진은씨는 여름철엔 어묵이, 겨울철엔 슬러시가 잘 팔리지 않아 항상 음식들을 폐기 해야만 했습니다. 해결 방법을 고민하던 진은씨는 최근에 출시된 해당 시스템에 대한 소식을 듣고 놀라게 됩니다. 바로 해당 시스템에 가게 마감 전 남은 음식을 폐기하지 않고, 고객들에게 무료로 나눔 하거나 저렴한 가격에 판매할 수 있는 기능이 있다는 것을 알게 되었기 때문입니다.

진은씨네 분식집에서 “어묵, 떡볶이, 국밥 마감 전에 무료 나눔합니다~ 배고프신 분들은 와서 받아 가세요~!”라는 글을 게시합니다. 마침 야식이 먹고 싶었던 태기씨는 진은씨네 분식집에 가까이 살고 있어 ‘공유 참여’를 통해 해당 가게에 방문하여 남은 음식을 무료로 제공 받았습니다.

해당 기능을 통해 진은씨는 음식물 쓰레기를 줄였고, 태기씨는 출출한 배를 든든하게 채웠습니다. 이때 고객인 태기씨는 자신이 받아갈 음식 용기를 가져오거나, 배달 받기를 원하면 배달 비용을 별도로 지불하여야 합니다.

### 문제점

1. 1인 가구가 음식을 배달 시킬 때 배달 비용에 대한 부담이 다인 가구 보다 크다.
2. 1인 가구가 많은 양의 음식을 주문할 때 음식물 쓰레기가 발생한다.
3. 매장에서 남은 음식물 배출 시 처리 비용이 발생한다. 

### 서비스 도입 방안

관리자

- ‘공유’ 기능에 필요한 용기를 ‘공유’ 서비스에 참여하는 가게에 지급

소비자

- 포장, 배달과 같은 기존 서비스 이용 시 포인트를 지급하고 포인트 활용하여 ‘공유’기능에서 사용 되는 수수료 절감

가게

- 가게는 기존 시스템을 유지하되 공유 기능이 필요한 주문이 들어왔을 때 나눠 담는 과정 추가
- 가게가 나누어 담는 시간적, 인건적 비용을 웹 페이지 상단에서 가게를 광고하는 비용 할인을 통해 상쇄

### 주요 기능

- 공유 기능은 카테고리 식의 태그를 이용해 공유 음식 분류
- ‘당근마켓’과 같은 위치 기반 서비스를 통해 공유를 더 쉽게 가능
- ‘공유’기능의 게시물 및 채팅 등 앱과 같은 간편한 UI/UX 제공
- MSA방식으로 기능 시스템을 컨테이너화 해서 쉽고 유연한 배포
- 자바 애노테이션(트랜잭션 관련)을 활용한 트랜잭션 처리 개선

### 논의 및 해결 로그

1. 처음 기획 시 가상의 플랫폼 뿐만 아니라 음식을 분배 대행할 물리적인 플랫폼 구현까지 생각하였음.
    
    → 초기 설치 비용과 물리적 서비스 구현 가능성을 고려하여 물리적인 플랫폼은 구현하지 않는 것으로 결정
    
2. 만약 공유 중개를 한다면 음식 전달 방식은 어떻게 될 것인 지에 대해 논의하였음.
    
    → 두 개의 음식을 공유한다면 한 가게에서 다른 가게로 배달을 하고 그 가게에서 음식을 나눠 담는 방법과 직접 만나서 나눠 담는 방법을 고안하였으나 전자는 가게 섭외 문제와 배달 비용이 두 배로 드는 상황 때문에 고려하지 않기로 함. 후자는 이후에 논의를 통해 결정하기로 함. 
    
3. 위의 논의점들을 통해 프로젝트의 취지를 다시 논의하게 됨. 과연 이러한 문제점들을 가지고 공유 서비스를 기획할 수 있을까?
    
    → 피자, 치킨, 탕수육 등 남겨 뒀다가 다음에 먹으려고 양을 넉넉하게 시키는 사람들도 있음. 하지만, 공유 서비스는 하나의 기능일 뿐 이것을 꼭 이용해야만 하는 것이 아니므로 기존 배달 서비스에서 확장 시켜 공유 기능을 추가하는 방향으로 결정함.
    
4. 그렇다면 공유 기능은 무료로 제공되는 기능인가?
    
    → 기존 시장의 흐름을 최대한 파괴하지 않는 선에서 방법을 고안하였음. 공유 기능을 할 때 수수료를 두는 것임. 큰 금액이 아닌 적당히 작은 금액을 기준으로 고객들은 공유 기능을 사용할 수 있음. 공유 기능의 무분별한 사용 남발이 야기하는 가게 측의 반발은 심하지 않을 것임.
    
5. 공유 기능을 어떻게 구현할 것인가?
    
    → 게시판의 형태로 직접 고객들이 게시물을 게시할 것인지, 아니면 태그 기능을 통해 어떤 음식, 공유 위치 등 조건을 적용하여 간단하게 웹 페이지에 게시될 지를 논의 하였음. 해당 논의점에 대해 가게 상호, 지역, 음식 종류 등 필수적인 정보들만 태그들로 게시 되도록 하고, 고객이 공유에 참여하는 순간 공유자들끼리의 채팅방을 공유 시간 동안 오픈하여 소통할 수 있도록 구현하기로 함.
    
6. 공유 배달 문제 : 예시로 하나의 배달 음식을 주문하여 두 명이 나누어야 할 때 생기는 문제
    
    고객들이 직접 만나 음식을 나누게 되면 위생 문제가 발생한다.
    
    → 가게에 직접 두 가지 이상의 음식을 담을 수 있는 용기를 제공하여 하나의 음식을 나눠 담도록 한다.
    
    고객들에게 배달 대행 서비스를 통해 배달한다.
    
    → 하나의 음식을 두 개로 나누었을 때 각각의 가정에 배달되게 된다면 1인분 배달의 기능과 차별화가 되지 않는다.
    

### 목표

- 1인 가구에게 불리한 기존 배달 시스템의 문제점을 배달 공유 시스템 개발을 통해 배달 비용 부담을 줄인다.
- 1인 가구에서 일어나는 배달 음식 낭비를 해당 시스템을 통해 버려지는 음식물을 줄인다.
- 양이 많은 음식을 나눔으로써 작은 양의 여러 종류의 음식을 먹을 수 있는 공유 시스템을 개발한다.
- 가게에서 폐기해야 할 음식을 시스템에 등록하여 저렴한 가격에 제공한다.
- 위를 빠르고 쉽게 이용 가능한 프론드엔드, 백엔드, 데이터베이스를 포함한 웹 서비스를 구현한다.

### 대상

- 배달 서비스를 이용하는 1인 가구
- 적은 양의 여러 종류의 음식을 주문하는 소비자
- 배달 서비스를 이용하는 가게

### 역할

- 프로젝트 아이디어 구체화, 논리적 보완점 수정, 프로젝트 검토 및 수정을 함께 회의를 통해 진행한다.
- sitemap, flowchart, wireframe, ERD, storyboard 는 역할을 나누어 제작한다.
- UI 개발 및 시스템 구현은 기능에 따라 화면 별로 나뉜다.
- 구현할 때 각자의 역할은 화면 별로 풀스택 개발이다.
- 자세한 역할 분담은 sitemap과 wireframe, storyboard 제작 후 결정한다.
- 마지막으로 배포 및 테스트, 개발 마무리 및 정리는 함께 진행한다.

### 사용할 기술 스택

<img src="https://s3-us-west-2.amazonaws.com/secure.notion-static.com/7ed5d528-1002-4077-b874-b50126bc8a8b/Untitled.png" />

<ing src="https://s3-us-west-2.amazonaws.com/secure.notion-static.com/e4b7a768-8bc3-4374-a097-03c1f2611cda/Untitled.png" />

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/438d69a5-72f0-415f-b9dc-704e3c5c69cc/Untitled.png)

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/fefd0b49-5fef-4685-bb58-868a451c7ea5/Untitled.png)

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/03924e25-eb54-40ea-9903-0de3fd8d0248/Untitled.png)

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/215e1c47-6cf5-4f32-bf0d-d37b6cbc51bc/Untitled.png)

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/b84c44c7-63a3-40a1-9914-c926328a7ede/Untitled.png)

프론트 엔드 : 아래의 이유로 프론트 엔드 라이브러리로 vue.js를 사용합니다.

1. Vue.js
    - 상대적으로 가벼운 라이브러리로, **학습 곡선**이 낮음
    - 가상 DOM 기반 렌더링으로, 성능 우수
    - 반응형 데이터 바인딩 기능이 내장되어 있어, **상태 관리 용이**
    - 생산성이 높고 **간결한 문법**
    - 컴포넌트 기반 구조로, 재사용성 높음
    
    → 프론트엔드 지식이 부족하며, 서로의 코드를 알아보기 쉬워 협업에 유리하여 사용
    

백 엔드 : Spring framework

- 경량 컨테이너로서 자바 객체를 직접 관리한다. 각각의 객체 생성, 소멸과 같은 라이프 사이클을 관리하며 스프링으로부터 필요한 객체를 얻어올 수 있다.
- 스프링은 [제어 반전](https://ko.wikipedia.org/wiki/%EC%A0%9C%EC%96%B4_%EB%B0%98%EC%A0%84)(IoC : Inversion of Control)을 지원한다. 컨트롤의 제어권이 사용자가 아니라 프레임워크에 있어서 필요에 따라 스프링에서 사용자의 코드를 호출한다.
- 스프링은 [의존성 주입](https://ko.wikipedia.org/wiki/%EC%9D%98%EC%A1%B4%EC%84%B1_%EC%A3%BC%EC%9E%85)(DI : Dependency Injection)을 지원한다. 각각의 계층이나 서비스들 간에 의존성이 존재할 경우 프레임워크가 서로 연결시켜준다.
- 스프링은 [관점 지향 프로그래밍](https://ko.wikipedia.org/wiki/%EA%B4%80%EC%A0%90_%EC%A7%80%ED%96%A5_%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D)(AOP : Aspect-Oriented Programming)을 지원한다. 따라서 [트랜잭션](https://ko.wikipedia.org/wiki/%ED%8A%B8%EB%9E%9C%EC%9E%AD%EC%85%98)이나 로깅, 보안과 같이 여러 모듈에서 공통적으로 사용하는 기능의 경우 해당 기능을 분리하여 관리할 수 있다.
- 스프링은 확장성이 높다. 스프링 프레임워크에 통합하기 위해 간단하게 기존 라이브러리를 감싸는 정도로 스프링에서 사용이 가능하기 때문에 수많은 라이브러리가 이미 스프링에서 지원되고 있고 스프링에서 사용되는 라이브러리를 별도로 분리하기도 용이하다.
- POJO 기반의 구성을 통해 개발자가 특정한 라이브러리나 컨테이너의 기술에 종속적이지 않게 된다.
- Java 코드를 이용해서 객체를 구성하는 방식을 통해 자유롭게 객체지향적 설계를 구현할 수 있다.
- 개발자는 가장 일반적인 형태로 코드를 작성하고 실행할 수 있다. 때문에 높은 생산성과 유연한 테스트를 할 수 있다는 장점을 가진다.

→  개발에 필요한 구조를 이미 코드 만들어 놓았기 때문에 개발 시간이 단축됨.

DI를 통해 단위 테스트를 할 수 있어 테스트에 용이하므로 협업 시 활용도 좋음.

AOP를 통해 복잡한 코드를 줄여 코드 리뷰가 수월함.

데이터베이스 : mongoDB

→ 서비스 특성 상 트래픽 처리 부분에서 고성능인 NoSQL을 선택함.

→ MSA 방식으로 컨테이너화 된 기능들에 각각의 DB를 연결하여 클러스터링 할 수 있음.

배포 툴 : AWS EC2 + Docker

1. 개발 생산성: Docker를 사용하면 로컬 환경에서 개발할 때 애플리케이션의 구성과 의존성을 미리 설정할 수 있으므로, 개발 생산성이 향상됩니다.
2. 배포 단순화: Docker를 사용하면 애플리케이션을 가볍고 이식 가능한 컨테이너로 패키징할 수 있으므로, 배포가 더욱 쉬워집니다.
3. 유연한 확장성: EC2는 필요에 따라 컴퓨팅 리소스를 수평으로 확장할 수 있으므로, 애플리케이션의 부하가 증가할 때 서비스를 빠르게 확장할 수 있습니다.

→ 요구되는 MSA에 맞는 추가 데이터 베이스 구축 시 확장 용이

→ 팀 특성 상 비대면 개발이므로 로컬 테스트 및 클라우드 배포로 CI/CD 용이

협업 툴 : GitHub, Notion

1. **GitHub**
    1. 버전 관리
        - 소스 코드 변경 이력 추적 및 비교
        - 이전 버전으로 롤백 가능
    2. 협업
        - 다수의 사용자가 함께 작업 가능
        - 코드 리뷰 기능 제공
    
    → 프로젝트 코드 및 브랜치 활용 개발을 위해 사용
    
2. **Notion:**
    1. 프로젝트 관리
        - 간단하게 프로젝트를 만들어 관리 가능
        - 태그, 필터 등의 기능으로 프로젝트 내용을 정리하고 검색 가능
    2. 문서 작성 및 공유
        - 다양한 문서 형식 지원 (문서, 스프레드시트, 노트 등)
        - 팀원과 문서를 공유하고 함께 작업할 수 있는 기능 제공
    
    → 프로젝트 개요, 일정, 미팅 등을 쉽게 공유할 수 있는 공간 마련하기 위해 사용
